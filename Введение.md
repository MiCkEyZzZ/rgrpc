# Введение в gRPC

Эта страница знакомит вас с gRPC и буферами протоколов(protocol buffers).
gRPC может использовать буферы протоколов(protocol buffers) как в качестве языка
определения интерфейса (IDL), так и в качестве базового формата обмена сообщениями.
Если вы новичок в gRPC и/или буферах протоколов(protocol buffers), прочтите это!

## Обзор

В gRPC клиентское приложение может напрямую вызывать метод серверного приложения
на другом компьютере, как если бы это был локальный объект, что упрощает создание
распределенных приложений и служб. Как и во многих системах RPC, gRPC основан на
идее определения службы, определения методов, которые можно вызывать удаленно, с
их параметрами и типами возвращаемых значений. На стороне сервера сервер реализует
этот интерфейс и запускает сервер gRPC для обработки клиентских вызовов. На стороне
клиента у клиента есть заглушка (в некоторых языках именуемая просто клиентом),
которая предоставляет те же методы, что и сервер.

![alt text](./imgs/1.svg)

Клиенты и серверы gRPC могут работать и взаимодействовать друг с другом в различных 
средах — от серверов внутри Google до вашего собственного рабочего стола — и могут 
быть написаны на любом из поддерживаемых gRPC языков. Так, например, вы можете 
легко создать сервер gRPC на Java с клиентами на Go, Python или Ruby. Кроме того, 
новейшие API Google будут иметь версии своих интерфейсов gRPC, что позволит вам 
легко встраивать функции Google в свои приложения.

## Работа с буферами протоколов(protocol buffers)

По умолчанию gRPC использует Protocol Buffers, зрелый механизм от Google с открытым 
исходным кодом для сериализации структурированных данных (хотя его можно использовать 
и с другими форматами данных, такими как JSON). Вот краткое введение в то, как это
работает. Если вы уже знакомы с буферами протоколов, смело переходите к 
следующему разделу.

Первым шагом при работе с буферами протоколов является определение структуры данных, 
которые вы хотите сериализовать в прото-файле: это обычный текстовый файл с расширением .proto. 
Данные буфера протокола структурированы как сообщения, где каждое сообщение представляет 
собой небольшую логическую запись информации, содержащую ряд пар "имя-значение", 
называемых полями. Вот простой пример:

```proto
message Person {
  string name = 1;
  int32 id = 2;
  bool has_ponycopter = 3;
}
```

Затем, после того как вы указали свои структуры данных, вы используете протокол 
компилятора буфера протокола для создания классов доступа к данным на предпочитаемом 
вами языке (языках) из вашего определения proto. Они предоставляют простые средства 
доступа для каждого поля, такие как name() и set_name(), а также методы для 
сериализации/анализа всей структуры в/из необработанных байтов. Так, например, 
если вы выбрали язык C++, запуск компилятора в приведенном выше примере сгенерирует 
класс с именем Person. Затем вы можете использовать этот класс в своем приложении 
для заполнения, сериализации и извлечения сообщений буфера протокола Person.

Вы определяете службы gRPC в обычных прото-файлах с параметрами метода RPC и 
типами возвращаемых значений, указанными в виде сообщений буфера протокола:

```c++
// Определение службы приветствия.
service Greeter {
  // Отправляет приветствие
  rpc SayHello (HelloRequest) returns (HelloReply) {}
}

// Сообщение запроса, содержащее имя пользователя.
message HelloRequest {
  string name = 1;
}

// Ответное сообщение с приветствием
message HelloReply {
  string message = 1;
}
```

gRPC использует protoc со специальным подключаемым модулем gRPC для генерации кода 
из вашего прото-файла: вы получаете сгенерированный код клиента и сервера gRPC, а 
также обычный код буфера протокола для заполнения, сериализации и извлечения ваших 
типов сообщений. Чтобы узнать больше о буферах протоколов, в том числе о том, как 
установить protoc с подключаемым модулем gRPC на выбранном вами языке, см. 
[документацию по буферам протоколов](https://protobuf.dev/overview/).

## Версии буфера протокола

Хотя [буферы протоколов](https://protobuf.dev/overview/) 
уже некоторое время доступны для пользователей с открытым исходным кодом, в 
большинстве примеров с этого сайта используются буферы протоколов 
версии 3 (proto3), которая имеет слегка упрощенный синтаксис, некоторые полезные 
новые функции и поддерживает больше языков. Proto3 в настоящее время доступен 
на Java, C++, Dart, Python, Objective-C, C#, lite-runtime (Android Java), Ruby и 
JavaScript [из репозитория протокольных буферов GitHub](https://github.com/protocolbuffers/protobuf/releases), а также в качестве 
генератора языка Go из [golang/. официальный пакет protobuf](https://pkg.go.dev/google.golang.org/protobuf) с большим количеством 
языков в разработке. Вы можете узнать больше в руководстве [по языку proto3]((https://protobuf.dev/programming-guides/proto3/)) и 
справочной документации](https://protobuf.dev/reference/), доступной для каждого языка. 
Справочная документация также включает формальную спецификацию формата файла .proto.

В целом, несмотря на то, что вы можете использовать proto2 (текущая версия 
буферов протокола по умолчанию), мы рекомендуем вам использовать proto3 с gRPC, 
поскольку он позволяет использовать весь спектр языков, поддерживаемых gRPC, а 
также позволяет избежать проблем совместимости с клиентами proto2, общающимися с 
серверами proto3 и наоборот.

# Основные концепции, архитектура и жизненный цикл

Введение в ключевые понятия gRPC с обзором архитектуры gRPC и жизненного цикла RPC.

Не знакомы с gRPC? Сначала прочитайте Введение в gRPC. Для получения подробной 
информации о конкретном языке см. краткое руководство, руководство и справочную 
документацию для выбранного вами языка.

## Обзор
### Определение услуги

Как и многие системы RPC, gRPC основан на идее определения службы, определения 
методов, которые можно вызывать удаленно, с их параметрами и типами возвращаемых 
значений. По умолчанию gRPC использует буферы протокола в качестве языка 
определения интерфейса (IDL) для описания как интерфейса службы, так и структуры 
сообщений полезной нагрузки. При желании можно использовать и другие альтернативы.

```proto
service HelloService {
  rpc SayHello (HelloRequest) returns (HelloResponse);
}

message HelloRequest {
  string greeting = 1;
}

message HelloResponse {
  string reply = 1;
}
```

gRPC позволяет определить четыре типа метода обслуживания:

* Унарные RPC, в которых клиент отправляет один запрос на сервер и получает один 
ответ, как при обычном вызове функции.

```proto
rpc SayHello(HelloRequest) returns (HelloResponse);
```
* Серверные потоковые RPC, в которых клиент отправляет запрос на сервер и 
получает поток для чтения последовательности сообщений. Клиент читает из 
возвращенного потока до тех пор, пока не останется сообщений. gRPC гарантирует 
упорядочение сообщений в рамках отдельного вызова RPC.

```proto
rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse);
```

* Клиентские потоковые RPC, в которых клиент записывает последовательность 
сообщений и отправляет их на сервер, опять же используя предоставленный поток. 
Как только клиент закончил писать сообщения, он ждет, пока сервер прочитает их 
и вернет свой ответ. Опять же, gRPC гарантирует порядок сообщений в рамках 
отдельного вызова RPC.

```proto
rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse);
```

* Двунаправленные потоковые RPC, в которых обе стороны отправляют последовательность 
сообщений, используя поток чтения-записи. Два потока работают независимо, 
поэтому клиенты и серверы могут читать и записывать в любом порядке: например, 
сервер может дождаться получения всех клиентских сообщений, прежде чем писать 
свои ответы, или он может попеременно читать сообщение, а затем писать сообщение, 
или какая-либо другая комбинация операций чтения и записи. Порядок сообщений в 
каждом потоке сохраняется.

```proto
rpc BidiHello(stream HelloRequest) returns (stream HelloResponse);
```

Вы узнаете больше о различных типах RPC в разделе [жизненного цикла RPC](https://grpc.io/docs/what-is-grpc/core-concepts/#rpc-life-cycle) ниже.

### Использование API

Начиная с определения службы в файле .proto, gRPC предоставляет подключаемые 
модули компилятора буфера протокола, которые генерируют клиентский и серверный 
код. Пользователи gRPC обычно вызывают эти API на стороне клиента и реализуют 
соответствующий API на стороне сервера.

* На стороне сервера сервер реализует методы, объявленные службой, и запускает 
сервер gRPC для обработки клиентских вызовов. Инфраструктура gRPC декодирует 
входящие запросы, выполняет методы службы и кодирует ответы службы.
* На стороне клиента у клиента есть локальный объект, известный как заглушка 
(для некоторых языков предпочтительным термином является клиент), который 
реализует те же методы, что и служба. Затем клиент может просто вызывать эти 
методы для локального объекта, а методы заключают параметры для вызова в 
соответствующий тип сообщения буфера протокола, отправляют запросы на сервер и 
возвращают ответы буфера протокола сервера.

### Синхронный против асинхронного

Синхронные RPC-вызовы этого блока до тех пор, пока не придет ответ от сервера, 
являются наиболее близким приближением к абстракции вызова процедуры, к которой 
стремится RPC. С другой стороны, сети по своей природе асинхронны, и во многих 
сценариях полезно иметь возможность запускать RPC, не блокируя текущий поток.

API программирования gRPC на большинстве языков поставляется как в синхронном, 
так и в асинхронном вариантах. Вы можете узнать больше в учебнике и справочной 
документации по каждому языку (скоро появятся полные справочные документы).

### Жизненный цикл RPC

В этом разделе вы более подробно рассмотрите, что происходит, когда клиент gRPC 
вызывает метод сервера gRPC. Подробные сведения о реализации см. на страницах, 
посвященных конкретному языку.

### Унарный RPC

Сначала рассмотрим простейший тип RPC, когда клиент отправляет один запрос и 
возвращает один ответ.

1. Как только клиент вызывает метод-заглушку, сервер уведомляется о том, что RPC 
был вызван с метаданными клиента для этого вызова, именем метода и указанным 
крайним сроком, если применимо.
2. Затем сервер может либо сразу же отправить обратно свои исходные метаданные 
(которые должны быть отправлены перед любым ответом), либо дождаться сообщения 
запроса от клиента. Что происходит первым, зависит от приложения.
3. Как только сервер получает сообщение запроса клиента, он выполняет всю 
необходимую работу по созданию и заполнению ответа. Затем ответ возвращается 
(в случае успеха) клиенту вместе со сведениями о состоянии (код состояния и 
необязательное сообщение о состоянии) и необязательными завершающими метаданными.
4. Если статус ответа OK, то клиент получает ответ, который завершает вызов на 
стороне клиента.

### Сервер потоковой передачи RPC

Серверный потоковый RPC подобен унарному RPC, за исключением того, что сервер 
возвращает поток сообщений в ответ на запрос клиента. После отправки всех 
сообщений клиенту отправляются сведения о состоянии сервера (код состояния и 
необязательное сообщение о состоянии) и необязательные завершающие метаданные. 
На этом обработка на стороне сервера завершена. Клиент завершает работу, когда 
получает все сообщения сервера.

### Клиентский потоковый RPC

RPC с клиентской потоковой передачей аналогичен унарному RPC, за исключением 
того, что клиент отправляет поток сообщений на сервер вместо одного сообщения. 
Сервер отвечает одним сообщением (вместе со сведениями о статусе и 
необязательными метаданными), как правило, но не обязательно, после того, как он 
получил все сообщения клиента.

### Двунаправленный потоковый RPC

В двунаправленном потоковом RPC вызов инициируется клиентом, вызывающим метод, 
и сервером, получающим клиентские метаданные, имя метода и крайний срок. Сервер 
может отправить обратно свои исходные метаданные или дождаться, пока клиент 
начнет потоковую передачу сообщений.

Обработка потока на стороне клиента и сервера зависит от приложения. Поскольку 
два потока независимы, клиент и сервер могут читать и записывать сообщения в 
любом порядке. Например, сервер может подождать, пока он не получит все сообщения 
клиента, прежде чем писать свои сообщения, или сервер и клиент могут играть в 
«пинг-понг» — сервер получает запрос, затем отправляет ответ, затем клиент 
отправляет другой запрос на основе ответа и так далее.

### Сроки/Тайм-ауты

gRPC позволяет клиентам указать, как долго они готовы ждать завершения RPC, 
прежде чем RPC будет завершен с ошибкой DEADLINE_EXCEEDED. На стороне сервера 
сервер может запросить, истекло ли время ожидания конкретного RPC или сколько 
времени осталось для завершения RPC.

Указание крайнего срока или тайм-аута зависит от языка: некоторые языковые API 
работают с точки зрения тайм-аутов (длительности времени), а некоторые языковые 
API работают с точки зрения крайнего срока (фиксированного момента времени) и 
могут иметь или не иметь крайний срок по умолчанию.

### Прекращение RPC

В gRPC и клиент, и сервер делают независимые и локальные определения успешности 
вызова, и их выводы могут не совпадать. Это означает, что, например, у вас может 
быть RPC, который успешно завершается на стороне сервера («Я отправил все свои 
ответы!»), но терпит неудачу на стороне клиента («Ответы получены после 
установленного срока!»). Сервер также может принять решение о завершении до того, 
как клиент отправит все свои запросы.

### Отмена RPC

Либо клиент, либо сервер могут отменить RPC в любое время. Отмена немедленно 
завершает RPC, чтобы дальнейшая работа не выполнялась.

** - Предупреждение
Изменения, сделанные до отмены, не откатываются. - **

### Метаданные

Метаданные — это информация о конкретном вызове RPC (например, сведения об 
аутентификации) в виде списка пар ключ-значение, где ключи — это строки, а 
значения — обычно строки, но могут быть и двоичными данными.

Ключи нечувствительны к регистру и состоят из букв ASCII, цифр и специальных 
символов -, _, . и не должен начинаться с grpc- (который зарезервирован для 
самого gRPC). Ключи с двоичным значением заканчиваются на -bin, а ключи с 
ASCII-значением — нет.

Пользовательские метаданные не используются gRPC, что позволяет клиенту 
предоставлять информацию, связанную с вызовом на сервер, и наоборот.

Доступ к метаданным зависит от языка.

### Каналы

Канал gRPC обеспечивает подключение к серверу gRPC на указанном узле и порту. 
Он используется при создании клиентской заглушки. Клиенты могут указать аргументы 
канала, чтобы изменить поведение gRPC по умолчанию, например включить или 
выключить сжатие сообщений. Канал имеет состояние, в том числе подключен и 
свободен.

То, как gRPC обрабатывает закрытие канала, зависит от языка. Некоторые языки 
также позволяют запрашивать состояние канала.
